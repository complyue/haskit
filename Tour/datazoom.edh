
import * 'net'
effect import * 'net/effects'

import * 'haskit'

effect import * 'haskit/demo-server'

# above will be automatically imported by `hski`
# %% # this importing cell may need manual execution

# import hasdim this way so:
#  *) all exported artifacts are directly available
#  *) all module level artifacts are available via `hd`
#  *) monkey-patching to the module object is possible
hd = { import * 'dim' }
# import effectful support for dtypes etc.
effect import * 'dim/effects'


# %% #
nPoints = 50001
nDetailMax = 501

# %% #
let xRaw = arange( nPoints, dtype=f8, )
let yRaw = cumsum$random( nPoints, -0.499..0.501, dtype=f8, )

# %% #
xSample = xRaw[0:nPoints:100]
ySample = yRaw[0:nPoints:100]

# %% #
nChg = 5
yChg = ySample.copy()
yChg[0:nChg] = nan
yChg[nChg:All] = ySample[nChg:All] - ySample[0: -nChg]

# %%

plot( 'demoGroup' ) $ {
  # Note this block is in-place interpreted, synchronously, per each connected root window

  syncedRangeX = perform defineViewRange( 'x' )

  splRangeX = perform defineViewRange( 'splX' )
  splRangeY = perform defineViewRange( 'splY' )
  chgRangeX = perform defineViewRange( 'chgX' )
  chgRangeY = perform defineViewRange( 'chgY' )
  dtlRangeX = perform defineViewRange( 'dtlX' )
  dtlRangeY = perform defineViewRange( 'dtlY' )

  focusedFigure = perform defineViewFocus( 'focusedFigure' )
  focusedPoint = perform defineAxisCursor( 'focusedPoint' )

  splCursorPoint = perform defineAxisCursor( 'splCursorPoint' )
  chgCursorPoint = perform defineAxisCursor( 'chgCursorPoint' )
  dtlCursorPoint = perform defineAxisCursor( 'dtlCursorPoint' )


  perform narrWindow( 'focusFigureNarr', 'Active Figure Info' ) $ {@

    perform @sendCmd(js!expr (async()=>{

          const figStory = narrator.addStoryLine(
            'focusFigureNarr', 'Active Figure Info',
            [ 'ffigName', 'ffigTitle', 'x', 'y', ],
            [ 'Figure Name', 'Figure Title', 'Cursor X', 'Cursor Y', ],
          )
          onViewFocusChange({$focusedFigure$}, (figName, figTitle)=>{
              figStory.updateNarremes({ffigName: figName, ffigTitle: figTitle})
          })
          onAxisCursorChange({$focusedPoint$},(x,y)=>{
              figStory.updateNarremes({ x: x, y: y, })
          })

          const syncStory = narrator.addStoryLine(
            'syncInfoNarr', 'Synchronization Info',
            [ 'syncRngX', ],
            [ "Sync'ed X Range", ],
          )
          onViewRangeChange({$syncedRangeX$}, (start, end)=>{
              syncStory.updateNarremes({ syncRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })

    })())

    return true {#
     # Disconnect the window, but keep this narration service mounted, so the window can be refreshed correctly.
     #}
  @}


  perform narrWindow( 'allFiguresNarr', 'All Figures Info' ) $ {@

    ds = perform defineDataSource(
      x= xSample, y= ySample, chg= yChg,
    )

    dsDetails = perform defineDataSource(
      x= xRaw, y= yRaw,
    )

    perform @sendCmd(js!expr (async()=>{

          const splStory = narrator.addStoryLine(
            'splStory', 'Sample Figure Info',
            [ 'shownRngX', 'shownRngY', 'x', 'y', 'dpx', 'dpy', ],
            [ 'Shown X Range', 'Shown Y Range',
              'Cursor X', 'Cursor Y',
              'Sample X', 'Sample Y', ],
          )
          onViewRangeChange({$splRangeX$}, (start, end)=>{
              splStory.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$splRangeY$}, (start, end)=>{
              splStory.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$splCursorPoint$},(x,y)=>{
              const xs = {$ds$}.data.x
              const di = Math.max(0, bounds.le(xs, x))
              splStory.updateNarremes({ x: x, y: y,
                  dpx: xs[di], dpy: {$ds$}.data.y[di], })
          })

          const chgStory = narrator.addStoryLine(
            'chgStory', 'Change Figure Info',
            [ 'shownRngX', 'shownRngY', 'x', 'y', 'dpx', 'dpy', ],
            [ 'Shown X Range', 'Shown Y Range',
              'Cursor X', 'Cursor Y',
              'Change X', 'Change Y', ],
          )
          onViewRangeChange({$chgRangeX$}, (start, end)=>{
              chgStory.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$chgRangeY$}, (start, end)=>{
              chgStory.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$chgCursorPoint$},(x,y)=>{
              const xs = {$ds$}.data.x
              const di = Math.max(0, bounds.le(xs, x))
              chgStory.updateNarremes({ x: x, y: y,
                  dpx: xs[di], dpy: {$ds$}.data.chg[di], })
          })

          const dtlStory = narrator.addStoryLine(
            'dtlStory', 'Details Figure Info',
            [ 'shownRngX', 'shownRngY', 'x', 'y', 'dpx', 'dpy', ],
            [ 'Shown X Range', 'Shown Y Range',
              'Cursor X', 'Cursor Y',
              'Data X', 'Data Y', ],
          )
          onViewRangeChange({$dtlRangeX$}, (start, end)=>{
              dtlStory.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$dtlRangeY$}, (start, end)=>{
              dtlStory.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$dtlCursorPoint$},(x,y)=>{
              const xs = {$dsDetails$}.data.x
              const di = Math.max(0, bounds.le(xs, x))
              dtlStory.updateNarremes({ x: x, y: y,
                  dpx: xs[di], dpy: {$dsDetails$}.data.y[di], })
          })


          onViewFocusChange({$focusedFigure$}, (figName, figTitle)=>{
              if ( 'figSample' === figName ) {
                splStory.focus()
              } else if ( 'figChange' === figName ) {
                chgStory.focus()
              } else if ( 'figDetails' === figName ) {
                dtlStory.focus()
              }
          })

    })())

    return true {#
     # Disconnect the window, but keep this narration service mounted, so the window can be refreshed correctly.
     #}
  @}


  perform plotWindow( 'demoSample', 'Downsampled Series' ) $ {@
    # Note this block is in-place interpreted, asynchronously, per every plot window connected (only if it opens the correct url), on their respective ws service thread
    # so it's better to be a scoped block for context isolation, unless with good reasons not to

    ds = perform defineDataSource(
      x= xSample, y= ySample, chg= yChg,
    )

    perform @sendCmd(js!expr (async()=>{

          const figSample = plt.figure({ name: 'figSample',
              title: 'Sample of the Series',
              toolbar_location: 'left',
              sizing_mode: 'stretch_both',
          })
          announceRange( figSample.x_range, {$ splRangeX $} )
          announceRange( figSample.y_range, {$ splRangeY $} )
          syncRange( figSample.x_range, {$ syncedRangeX $} )
          figSample.line({
              source: {$ds$},
              x: { field: 'x' },
              y: { field: 'y' },
              color: '#000000', alpha: 0.7,
              legend: 'Sample',
          })
          for(let g of figSample.select( bkh.Legend )) {
            g.location = 'top_left'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }


          const figChange = plt.figure({ name: 'figChange',
              title: 'Change of the Series',
              toolbar_location: 'right',
              sizing_mode: 'stretch_both',
          })
          announceRange( figChange.x_range, {$ chgRangeX $} )
          announceRange( figChange.y_range, {$ chgRangeY $} )
          syncRange( figChange.x_range, {$ syncedRangeX $} )
          figChange.line({
              source: {$ds$},
              x: { field: 'x' },
              y: { field: 'chg' },
              color: '#0000FF', alpha: 0.7,
              legend: 'Change',
          })
          for(let g of figChange.select( bkh.Legend )) {
            g.location = 'top_right'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }


          const plotView = await plt.show( plt.gridplot(
              [ [ figSample ], [ figChange ] ], {
                merge_tools: false,
                sizing_mode: 'stretch_both',
            } ), $('#plot') )

          const splView = findViewByModelName( 'figSample' )( plotView )
          announceFocus(splView, {$focusedFigure$})
          announceAxisCursor(splView, defaultScale, {$focusedPoint$})
          announceAxisCursor(splView, defaultScale, {$splCursorPoint$})

          const chgView = findViewByModelName( 'figChange' )( plotView )
          announceFocus(chgView, {$focusedFigure$})
          announceAxisCursor(chgView, defaultScale, {$focusedPoint$})
          announceAxisCursor(chgView, defaultScale, {$chgCursorPoint$})

    })())

    return true {#
     # Disconnect the window, but keep this plotting service mounted, so the window can be refreshed correctly.
     # CAVEAT
       This plot script (arrow procedure) captures the full hierearchy of its lexical scopes, kept mounted as a plotting service, all resources references by the closure are considered leaked in a sense.
     #}

    {#
     # Alternatively:
       * `return false` here will also keep the plotting service, and the ws connection to the plot window will also be kept connected, serving further RPC from browser js
       * otherwise this plot script is considered a one-shot, all resources are unreferenced then
     #}
  @}


  perform plotWindow( 'demoDetails', 'Series Details' ) $ {@
    # Note this block is in-place interpreted, asynchronously, per every plot window connected (only if it opens the correct url), on their respective ws service thread
    # so it's better to be a scoped block for context isolation, unless with good reasons not to

    ds = perform defineDataSource(
      x= xRaw[0:nDetailMax], y= yRaw[0:nDetailMax],
    )

    perform implantServices $ namespace _ () export {
      method updatePlotData(xStart, xEnd,) {
        dpStart = xStart.trunc
        dpStop = dpStart + min(nDetailMax, (1 + xEnd - dpStart).round)
        perform updateDataSource( ds,
          x= xRaw[dpStart:dpStop], y= yRaw[dpStart:dpStop],
        )
      }
    }

    perform @sendCmd(js!expr (async()=>{

          const figDetails = plt.figure({ name: 'figDetails',
              title: 'Detail of the Series',
              toolbar_location: 'left',
              sizing_mode: 'stretch_both',
          })
          announceRange( figDetails.x_range, {$ dtlRangeX $} )
          announceRange( figDetails.y_range, {$ dtlRangeY $} )
          figDetails.line({
              source: {$ds$},
              x: { field: 'x' },
              y: { field: 'y' },
              color: '#000000', alpha: 0.7,
              legend: 'Details',
          })
          for(let g of figDetails.select( bkh.Legend )) {
            g.location = 'top_left'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }


          const plotView = await plt.show( figDetails, $('#plot') )

          const dtlView = findViewByModelName( 'figDetails' )( plotView )
          announceFocus(dtlView, {$focusedFigure$})
          announceAxisCursor(dtlView, defaultScale, {$focusedPoint$})
          announceAxisCursor(dtlView, defaultScale, {$dtlCursorPoint$})


          onViewRangeChange({$syncedRangeX$}, (start, end)=>{
              hskiPageConn.ifAlive(peer => peer.postCommand(
                  `updatePlotData(${start}, ${end})`
              ))
          })

    })())

    return false {#
     # Keep the window connected and this plotting service mounted, so the window can keep requesting new plot data on-demand, also the window can be refreshed correctly as a side effect.
     # CAVEAT
       This plot script (arrow procedure) captures the full hierearchy of its lexical scopes, kept mounted as a plotting service, all resources references by the closure are considered leaked in a sense.
     #}
  @}

}
