
import * 'net'
effect import * 'net/effects'

import * 'haskit'

effect import * 'haskit/demo-server'

# above will be automatically imported by `hski`
# %% # this importing cell may need manual execution

# import hasdim this way so:
#  *) all exported artifacts are directly available
#  *) all module level artifacts are available via `hd`
#  *) monkey-patching to the module object is possible
hd = { import * 'dim' }
# import effectful support for dtypes etc.
effect import * 'dim/effects'


# %% #
nPoints = 50001

let xRaw = arange( nPoints, dtype=f8, )
let yRaw = cumsum$random( nPoints, -0.499..0.501, dtype=f8, )

# %% #
xSample = xRaw[0:nPoints:100]
ySample = yRaw[0:nPoints:100]

# %% #
nChg = 5
yChg = ySample.copy()
yChg[0:nChg] = nan
yChg[nChg:All] = ySample[nChg:All] - ySample[0: -nChg]

# %%

plot( 'randomGroup' ) $ {
  # Note this block is in-place interpreted, synchronously, per each connected root window

  syncedRangeX = perform defineViewRange( 'x' )

  splRangeX = perform defineViewRange( 'splX' )
  splRangeY = perform defineViewRange( 'splY' )
  chgRangeX = perform defineViewRange( 'chgX' )
  chgRangeY = perform defineViewRange( 'chgY' )

  focusedFigure = perform defineViewFocus( 'focusedFigure' )
  focusedPoint = perform defineAxisCursor( 'focusedPoint' )

  splCursorPoint = perform defineAxisCursor( 'splCursorPoint' )
  chgCursorPoint = perform defineAxisCursor( 'chgCursorPoint' )

  perform plotWindow( 'randomSample', 'Overview of Sampled Series' ) $ {@
    # Note this block is in-place interpreted, asynchronously, per every plot window connected (only if it opens the correct url), on their respective ws serive thread
    # so it's better to be a scoped block for context isolation, unless with good reasons not to

    ds = perform defineDataSource(
      x= xSample, y= ySample, chg= yChg,
    )

    perform @sendCmd(js!expr (async()=>{

          const figSample = plt.figure({ name: 'figSample',
              title: 'Sample of Random Series',
              toolbar_location: 'left',
              sizing_mode: 'stretch_both',
          })
          figSample.line({
              source: {$ ds $},
              x: { field: 'x' },
              y: { field: 'y' },
              color: '#000000', alpha: 0.7,
              legend: 'Sample',
          })
          for(let g of figSample.select( bkh.Legend )) {
            g.location = 'top_left'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }
          announceRange( figSample.x_range, {$ splRangeX $} )
          announceRange( figSample.y_range, {$ splRangeY $} )
          syncRange( figSample.x_range, {$ syncedRangeX $} )


          const figChange = plt.figure({ name: 'figChange',
              title: 'Change of Random Series',
              toolbar_location: 'left',
              sizing_mode: 'stretch_both',
          })
          figChange.line({
              source: {$ ds $},
              x: { field: 'x' },
              y: { field: 'chg' },
              color: '#0000FF', alpha: 0.7,
              legend: 'Change',
          })
          for(let g of figChange.select( bkh.Legend )) {
            g.location = 'top_right'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }
          announceRange( figChange.x_range, {$ chgRangeX $} )
          announceRange( figChange.y_range, {$ chgRangeY $} )
          syncRange( figChange.x_range, {$ syncedRangeX $} )


          const plotView = await plt.show( plt.gridplot(
              [ [ figSample ], [ figChange ] ], {
                merge_tools: false,
                sizing_mode: 'stretch_both',
            } ), $('#plot') )

          const splView = findViewByModelName( 'figSample' )( plotView )
          announceFocus(splView, {$focusedFigure$})
          announceAxisCursor(splView, defaultScale, {$focusedPoint$})
          announceAxisCursor(splView, defaultScale, {$splCursorPoint$})

          const chgView = findViewByModelName( 'figChange' )( plotView )
          announceFocus(chgView, {$focusedFigure$})
          announceAxisCursor(chgView, defaultScale, {$focusedPoint$})
          announceAxisCursor(chgView, defaultScale, {$chgCursorPoint$})

    })())

    return true {#
     # Disconnect the window, but keep this plotting service mounted, so the window can be refreshed correctly.
     # CAVEAT
       This plot script (arrow procedure) captures the full hierearchy of its lexical scopes, kept mounted as a plotting service, all resources references by the closure are considered leaked in a sense.
     #}

    {#
     # Alternatively:
       * `return false` here will also keep the plotting service, and the ws connection to the plot window will also be kept connected, serving further RPC from browser js
       * otherwise this plot script is considered a one-shot, all resources are unreferenced then
     #}
  @}


  perform narrWindow( 'focusFigureNarr', 'Active Figure Info' ) $ {@

    perform @sendCmd(js!expr (async()=>{

          const story = narrator.addStoryLine(
            'focusFigureNarr', 'Active Figure Info',
            [ 'ffigName', 'shownRngX', 'x', ],
            [ 'Figure Name', 'Observing X Range', 'X', ],
          )

          onViewRangeChange({$syncedRangeX$}, (start, end)=>{
              story.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })

          onViewFocusChange({$focusedFigure$}, (figName)=>{
              story.updateNarremes({ffigName: figName})
          })

          onAxisCursorChange({$focusedPoint$},(x,y)=>{
              story.updateNarremes({ x: x, })
          })

    })())

    return true {#
     # Disconnect the window, but keep this narration service mounted, so the window can be refreshed correctly.
     #}
  @}


  perform narrWindow( 'allFiguresNarr', 'All Figures Info' ) $ {@

    perform @sendCmd(js!expr (async()=>{

          const splStory = narrator.addStoryLine(
            'splStory', 'Sample Figure Info',
            [ 'shownRngX', 'shownRngY', 'x', 'y', 'v', ],
            [ 'Shown X Range', 'Shown Y Range', 'Cursor X', 'Cursor Y', 'Sample Value', ],
          )
          onViewRangeChange({$splRangeX$}, (start, end)=>{
              splStory.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$splRangeY$}, (start, end)=>{
              splStory.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$splCursorPoint$},(x,y)=>{
              splStory.updateNarremes({ x: x, y: y, v: '<todo>', })
          })

          const chgStory = narrator.addStoryLine(
            'chgStory', 'Change Figure Info',
            [ 'shownRngX', 'shownRngY', 'x', 'y', 'v', ],
            [ 'Shown X Range', 'Shown Y Range', 'Cursor X', 'Cursor Y', 'Sample Value', ],
          )
          onViewRangeChange({$chgRangeX$}, (start, end)=>{
              chgStory.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$chgRangeY$}, (start, end)=>{
              chgStory.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$chgCursorPoint$},(x,y)=>{
              chgStory.updateNarremes({ x: x, y: y, v: '<todo>', })
          })


          onViewFocusChange({$focusedFigure$}, (figName)=>{
              if ( 'figSample' === figName ) {
                splStory.focus()
              } else if ( 'figChange' === figName ) {
                chgStory.focus()
              }
          })

    })())

    return true {#
     # Disconnect the window, but keep this narration service mounted, so the window can be refreshed correctly.
     #}
  @}

}
