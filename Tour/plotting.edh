
import * 'haskit'

# %%

# import hasdim this way so:
#  *) all exported artifacts are directly available
#  *) all module level artifacts are available via `hd`
#  *) monkey-patching to the module object is possible
hd = { import * 'dim' }
# import effectful support for dtypes etc.
effect import * 'dim/effects'


# %%
nPoints = 500
nPhases = 8
x = arange( nPoints, dtype=f8 ) * nPhases / ( nPoints-1 )
xv = x * pi( nPoints, dtype=f8 )
ySin = sin( xv )
yCos = cos( xv )


# %%

for () from plot( 'demoPlotGroup1' ) do {
  syncedRangeX = perform defineViewRange( 'x' )
  syncedRangeY = perform defineViewRange( 'y' )

  sinRangeY = perform defineViewRange( 'sin' )
  cosRangeY = perform defineViewRange( 'cos' )

  focusedFigure = perform defineViewFocus( 'focusedFigure' )
  focusedPoint = perform defineAxisCursor( 'focusedPoint' )

  sinCursorPoint = perform defineAxisCursor( 'sinCursorPoint' )
  cosCursorPoint = perform defineAxisCursor( 'cosCursorPoint' )

  for () from perform plotWindow( 'demoPlotWin1' ) do {
    ds = perform defineDataSource(
      x= x, sin= ySin, cos= yCos,
    )

    perform postJsCode( js!expr (async()=>{

          const sinFig = plt.figure( { name: 'sin_curve',
              title: 'SIN Figure',
              toolbar_location: 'left',
              sizing_mode: 'stretch_both',
          } )
          sinFig.line( {
              source: {$ ds $},
              x: { field: 'x' },
              y: { field: 'sin' },
              color: '#1122cc',
              alpha: 0.7,
              legend: 'SIN Curve',
          } )
          announceRange( sinFig.y_range, {$ sinRangeY $} )
          syncRange( sinFig.x_range, {$ syncedRangeX $} )
          syncRange( sinFig.y_range, {$ syncedRangeY $} )

          const cosFig = plt.figure( { name: 'cos_curve',
              title: 'COS Figure',
              toolbar_location: 'right',
              sizing_mode: 'stretch_both',
          } )
          cosFig.line( {
              source: {$ ds $},
              x: { field: 'x' },
              y: { field: 'cos' },
              color: '#11cc22',
              alpha: 0.7,
              legend: 'COS Curve',
          } )
          for(let g of cosFig.select( bkh.Legend )) {
            g.location = 'top_left'
            g.click_policy = 'hide'
            g.background_fill_alpha = 0.6
          }
          announceRange( cosFig.y_range, {$ cosRangeY $} )
          syncRange( cosFig.x_range, {$ syncedRangeX $} )
          syncRange( cosFig.y_range, {$ syncedRangeY $} )

          const plotView = await plt.show( plt.gridplot(
              [ [ sinFig ], [ cosFig ] ], {
                merge_tools: false,
                sizing_mode: 'stretch_both',
            } ), document.body )

          const sinView = findViewByModelName( 'sin_curve' )( plotView )
          announceFocus(sinView, {$focusedFigure$})
          announceAxisCursor(sinView, defaultScale, {$focusedPoint$})
          announceAxisCursor(sinView, defaultScale, {$sinCursorPoint$})

          const cosView = findViewByModelName( 'cos_curve' )( plotView )
          announceFocus(cosView, {$focusedFigure$})
          announceAxisCursor(cosView, defaultScale, {$focusedPoint$})
          announceAxisCursor(cosView, defaultScale, {$cosCursorPoint$})

    })())

  }

  for () from perform narrWindow( 'demoNarrWin1' ) do {
    perform postJsCode( js!expr (async()=>{

          const story = narrator.addStoryLine(
            'demoStory1', 'Demo for sin/cos values',
            [ 'ffigName', 'shownRngX', 'shownRngY', 'x', ],
            [ 'Observing Function', 'Observing X Range', 'Observing Y Range', 'X', ],
          )


          onViewRangeChange({$syncedRangeX$}, (start, end)=>{
              story.updateNarremes({ shownRngX:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onViewRangeChange({$syncedRangeY$}, (start, end)=>{
              story.updateNarremes({ shownRngY:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })

          onViewFocusChange({$focusedFigure$}, (figName)=>{
              story.updateNarremes({ffigName: figName})
          })

          onAxisCursorChange({$focusedPoint$},(x,y)=>{
              story.updateNarremes({ x: x, y: y, })
          })

    })())
  }

  for () from perform narrWindow( 'demoNarrWin2' ) do {
    perform postJsCode( js!expr (async()=>{

          const storySin = narrator.addStoryLine(
            'demoStory1', 'Demo for sin values',
            [ 'shownRng', 'x', 'y', 'v', ],
            [ 'Shown Y Range', 'Cursor X', 'Cursor Y', 'SIN', ],
          )
          onViewRangeChange({$sinRangeY$}, (start, end)=>{
              storySin.updateNarremes({ shownRng:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$sinCursorPoint$},(x,y)=>{
              storySin.updateNarremes({ x: x, y: y, v: Math.sin(x*Math.PI), })
          })


          const storyCos = narrator.addStoryLine(
            'demoStory2', 'Demo for cos values',
            [ 'shownRng', 'x', 'y', 'v', ],
            [ 'Shown Y Range', 'Cursor X', 'Cursor Y', 'COS', ],
          )
          onViewRangeChange({$cosRangeY$}, (start, end)=>{
              storyCos.updateNarremes({ shownRng:
                  start.toFixed(2) + ' ~ ' + end.toFixed(2), })
          })
          onAxisCursorChange({$cosCursorPoint$},(x, y)=>{
              storyCos.updateNarremes({ x: x, y: y, v: Math.cos(x*Math.PI), })
          })


          onViewFocusChange({$focusedFigure$}, (figName)=>{
              if ( 'sin_curve' === figName ) {
                storySin.focus()
              } else if ( 'cos_curve' === figName ) {
                storyCos.focus()
              }
          })

    })())
  }

}
