{#
 # plotting procedures
 #}

import * 'net'
effect import * 'net/effects'

import * './web'
import * './utils'
import * './debug'


{##

Vend effectful API to plot a group of plotting windows against each hski client (root window)

An instance of `HaskItServer` (usually a descendant instance of it) must be in effect via `@haskItServer` key.

 #}
export generator plot( pgid ) void {
  {# note wrt the js!expr posted to web clients:
outer most curly braces are being interpreted as markers of a block of code in js `eval`, need to get it parenthese quoted, in case a dict (or JS object) literal is intended.
   #}
  hskiServer = perform @haskItServer
  hskiServer ?= HaskItServer()

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    nViewRanges = 0
    nViewFocuses = 0
    nAxisCursors = 0
  }

  effect method defineViewRange( vrName= 'view-range' ) {
    # use a shared counter to ensure uniqueness per view-range definition
    vrNum = ai pgData.nViewRanges+=1
    return vrName ++ '#' ++ vrNum ++ '@' ++ pgid
  }

  effect method defineViewFocus( vfName= 'view-focus' ) {
    # use a shared counter to ensure uniqueness per view-focus definition
    vfNum = ai pgData.nViewFocuses+=1
    return vfName ++ '#' ++ vfNum ++ '@' ++ pgid
  }

  effect method defineAxisCursor( acName= 'axis-cursor' ) {
    # use a shared counter to ensure uniqueness per axis-cursor definition
    acNum = ai pgData.nAxisCursors+=1
    return acName ++ '#' ++ acNum ++ '@' ++ pgid
  }

  for (rootPeer, rootSvcScope) from hskiServer.wsClientsOn('/') do {

    {##
Open the client plot window identified by `pwid`, vend effectful API to plot figures with glyphs in it
     #}
    effect method plotWindow( pwid, title= None ) plotScript => {
      servicePath = '/' ++ UUID() # allocate a unique service path
      hskiServer.mountServlet(servicePath) $ plotSvcScope => {

        # intermediate data for the plot window
        namespace pwData () {
          nds = 0
        }

        effect method defineDataSource(** cols ) {
          dsNum = ai pwData.nds+=1
          dsName = 'ds' + dsNum

          let ( colNames, colDtypes, ) = (*unzip$
            do ( k, v.dtype|str, ) for ( k, v ) from cols
          )
          # hskiDebug.replHere()
          perform @sendCmd(js!expr receiveDataSource(
              {$ dsName $},
              {$snippet$json$ colNames $},
              {$snippet$json$ colDtypes $},
          ) )
          for ( _k, v ) from cols do perform @sendData( blob$ v )

          return snippet$ 'plotData['++repr(dsName)++']'
        }

        # the plot script has to explicitly return a bool to keep the service mounted, or it'll get unmounted and further refresh of the browser window can get nothing plotted
        return case plotScript() of {
          # all done, disconnect this window as no further client/server interaction expected
          true -> true
          # initial plotting done, keep this window connected, further C/S interactions expected
          false -> false
          _ -> { # one-shot plotting, umount the service
            hskiServer.unmountServlet(servicePath)
            # todo which of the following is more correct?
            true # disconnect this window, no further C/S interactions expected
            # false # keep this window connected, further C/S interactions expected
          }
        }

      }

      plotUrl = '/plot.html?service=' ++ servicePath
      if title then plotUrl += (
        '&' ++ 'title=' ++ title # TODO urlEncode it
      )
      plotWinName = 'plot#' ++ pgid ++ '/' ++ pwid
      rootPeer.postCommand(js!expr
        window.open( {$plotUrl$}, {$plotWinName$}, )
      )
    }

    yield ()
  }

}
