{#
 # plotting procedures
 #}

import * './web'
import * './debug'


{## Helper for a piece of literal source text to be interpolated into an expression #}
export class snippet {
  method __init__(src) this.__repr__ = str(src)
}

{## Helper for a series of literal source text to be interpolated into an expression #}
export class snippets {
  method __init__(srcs) this.__repr__ = join(*srcs, sep='\n\n')
}


{##

Vend effectful API to plot a group of plotting windows against each connected hski client

An instance of `HaskItServer` (usually a descendant instance of it) must be in effect via `@haskItServer` key.

 #}
export generator plot( pgid ) void {
  {# note wrt the js!expr posted to web clients:
outer most curly braces are being interpreted as markers of a block of code in js `eval`, need to get it parenthese quoted, in case a dict (or JS object) literal is intended.
   #}

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    naxes = 0
  }

  effect method defineAxis( axisName= 'axis' ) {
    # use a shared counter to ensure uniqueness per axis definition
    axisNum = ai pgData.naxes+=1
    return axisName ++ '#' ++ axisNum ++ '@' ++ pgid
  }

  for hskiPeer from perform @haskItServer.clients() do {

    {##
Open the client plot window identified by `pwid`, vend effectful API to plot figures with glyphs in it
     #}
    effect generator plotWindow( pwid ) {
      # open the specified plot window from this root client window, establish the comm channel to it
      plotChannel = str( UUID() )
      plotSink = hskiPeer.armChannel( plotChannel )
      for ack from ( outlet= plotSink ) | () =>* {
        hskiPeer.postCommand( js!expr {
            void openPlotWindow( {$ pgid $}, {$ pwid $}, {$ plotChannel $} )
        } )
      } do {
        if ack is not 'plot-win-open'
        then error$ 'bug: bad handshake, check haze/plot-relay.mjs'

        break
      }

      # intermediate data for the plot window
      namespace pwData () {
        nds = 0
      }

      effect method defineDataSource(** cols ) {
        dsNum = ai pwData.nds+=1
        dsName = 'ds' + dsNum

        let ( colNames, colDtypes, ) = (*unzip$ for ( k, v ) from cols
          do ( k, v.dtype|str, )
        )
        # hskiDebug.replHere()
        hskiPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$str$ js!expr
                receiveDataSource(
                  {$ dsName $},
                  {$snippet$json$ colNames $},
                  {$snippet$json$ colDtypes $},
                )
              $}
        } ) )
        for ( _k, v ) from cols do {
          hskiPeer.p2c( plotChannel, js!expr ( { nextDir : 'data' } ) )
          hskiPeer.p2c( plotChannel, blob$ v )
        }

        return snippet$ 'plotData['++repr(dsName)++']'
      }

      effect method postJsCode( jsExpr ) {
        hskiPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$str$ jsExpr $}
        } ) )
      }

      yield ()
    }

    yield ()
  }

}
