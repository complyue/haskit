{#
 # plotting procedures
 #}


export data dataField ( x ) {
  method __repr__() {
    repr$ js!expr { field: {$ this.x|str $} }
  }
  __str__ = __repr__
}

export data dataValue ( x ) {
  method __repr__() {
    repr$ js!expr { value: {$ this.x $} }
  }
  __str__ = __repr__
}


plot :: ( HaskItServer, Any as 'the plot group id',
  # these effects materialized in module `haskit/web/ws/__main__.edh`
  { effect {
      # will be the HaskItServer passed in
      hski :: HaskItServer
      # the peer object connected through WebSocket,
      # from root window of the web client
      hskiPeer :: Peer
      # standard data channel sink by Nedh convention
      @dataSink :: EventSink
      # also the same peer object as `hskiPeer`, by Nedh convention
      @netPeer :: Peer
  } } => () -> Any as 'the group plot script',
) -> nil
export method plot( hski, pgid, grpPlotScript ) {

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    naxes = 0
  }

  hski.clientsEachDo $ rootWsPeer => {

    effect method defineAxis( axisName= 'axis' ) {
      # use a shared counter to isolate different root client windows from
      # synchronizing axes with eachothers
      axisNum = ai pgData.naxis+=1
      return axisName ++ '#' ++ axisNum ++ '@' ++ pgid
    }

    effect method plotWindow( pwid, winPlotScript ) {
      # open a new plot window from this root client window, establish the
      # comm channel to it
      plotChannel = str( UUID() )
      plotSink = rootWsPeer.armChannel( plotChannel )
      for ack from producer _ () {
        rootWsPeer.postCommand( js!expr {
            openPlotWindow( {$ pgid $}, {$ pwid$}, {$ plotChannel$} )
        } )
      } ( outlet=plotSink ) do {
        if ack is not 'plot-win-open'
        then error$ 'bug: bad handshake, check haze/plot-relay.mjs'
        break
      }

      # intermediate data for the plot window
      namespace pwData () {
        nds = 0
      }

      effect method defineDataSource(** cols ) {
        dsNum = ai pwData.nds+=1
        dsName = 'ds' + dsNum

        colNames = [] =< for ( k, _v ) from cols do k
        colDtypes = [] =< for ( _k, v ) from cols do v.dtype|str
        rootWsPeer.p2c( plotChannel, js!expr {
            'plotCmd' : {$ str$ js!expr
              receiveDataSource(
                {$ dsName $}, {$ colNames $}, {$ colDtypes $},
              )
            $}
        } )
        for ( _k, v ) from cols do {
          rootWsPeer.p2c( plotChannel, { 'nextDir' : 'data' } )
          rootWsPeer.p2c( plotChannel, v|blob )
        }

        return dsName
      }

      effect method figure() {

      }

      winPlotScript()
    }

    grpPlotScript()
  }

}
