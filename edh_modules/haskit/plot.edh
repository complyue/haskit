{#
 # plotting procedures
 #}

import * 'haskit'


export data jsSnippet ( jsSrc ) {
  method __repr__() this.jsSrc
  __str__ = __repr__
}


{## Type description for a plot script

The plot script is an expression to be evaluated with effectful helper procedures for plotting, it can assume availability of the effectful artifacts described here

 #}
PlotScript :=: {
  # these effects materialized in module `haskit/web/ws/__main__.edh`
  effect {

    # the effective HaskItServer instance
    ; @haskItServer :: HaskItServer
    # the peer object connected through WebSocket,
    # from root window of the web client
    ; @haskItPeer :: Peer

    # standard data channel sink by Nedh convention
    ; @dataSink :: sink
    # also the same peer object as `hskiPeer`, by Nedh convention
    ; @netPeer :: Peer

    method defineAxis( axisName= 'axis', ) pass
    method plotWindow( pwid, winPlotScript, ) pass
    method defineDataSource(** cols ) pass
    method postJsCode( jsExpr ) pass

  }
} => () -> Any


{## Plot a group with specified script

An instance of `HaskItServer` (usually a descendant instance of it) must be in effect via `@haskItServer` key.

Especially note that the plot script can be evaluated multiple times and concurrently, when multiple clients are connected, so it's usually a good idea to use a scoped block to wrap the plotting statements, unless you have good reasons not to.

 #}
plot :: { effect {
    # the effective HaskItServer instance
    ; @haskItServer :: HaskItServer
} } => ( 'the plot group id'!Any, PlotScript!ExprType, ) -> nil
export interpreter plot( callerScope, pgidExpr, grpPlotScript, ) void {
  pgid = callerScope.eval(pgidExpr)

  {# note wrt the js!expr posted to web clients:
outer most curly braces are being interpreted as markers of a block of code in js `eval`, need to get it parenthese quoted, in case a dict (or JS object) literal is intended.
   #}

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    naxes = 0
  }

  perform @haskItServer.clientsEachDo $ crPeer => {

    effect method defineAxis( axisName= 'axis' ) {
      # use a shared counter to isolate different root client windows from
      # synchronizing axes with eachothers
      axisNum = ai pgData.naxes+=1
      return axisName ++ '#' ++ axisNum ++ '@' ++ pgid
    }

    effect method plotWindow( pwid, winPlotScript, ) {
      # open a new plot window from this root client window, establish the
      # comm channel to it
      plotChannel = str( UUID() )
      plotSink = crPeer.armChannel( plotChannel )
      for ack from ( outlet= plotSink ) | () =>* {
        crPeer.postCommand( js!expr {
            void openPlotWindow( {$ pgid $}, {$ pwid $}, {$ plotChannel $} )
        } )
      } do {
        if ack is not 'plot-win-open'
        then error$ 'bug: bad handshake, check haze/plot-relay.mjs'

        break
      }

      # intermediate data for the plot window
      namespace pwData () {
        nds = 0
      }

      effect method defineDataSource(** cols ) {
        dsNum = ai pwData.nds+=1
        dsName = 'ds' + dsNum

        colNames = [] =< for ( k, _v ) from cols do k
        colDtypes = [] =< for ( _k, v ) from cols do str( v.dtype )
        crPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$ str$ js!expr
                receiveDataSource(
                  {$ dsName $}, {$ colNames $}, {$ colDtypes $},
                )
              $}
        } ) )
        for ( _k, v ) from cols do {
          crPeer.p2c( plotChannel, js!expr ( { nextDir : 'data' } ) )
          crPeer.p2c( plotChannel, blob$ v )
        }

        return dsName
      }

      effect method postJsCode( jsExpr ) {
        crPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$ str$ jsExpr $}
        } ) )
      }

      winPlotScript()
    }

    callerScope.eval(grpPlotScript)

  }

}
