{#
 # plotting procedures
 #}

import * './web'
import * './utils'
import * './debug'


{##

Vend effectful API to plot a group of plotting windows against each connected hski client

An instance of `HaskItServer` (usually a descendant instance of it) must be in effect via `@haskItServer` key.

 #}
export generator plot( pgid ) void {
  {# note wrt the js!expr posted to web clients:
outer most curly braces are being interpreted as markers of a block of code in js `eval`, need to get it parenthese quoted, in case a dict (or JS object) literal is intended.
   #}

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    nViewRanges = 0
    nViewFocuses = 0
    nAxisCursors = 0
  }

  effect method defineViewRange( vrName= 'view-range' ) {
    # use a shared counter to ensure uniqueness per view-range definition
    vrNum = ai pgData.nViewRanges+=1
    return vrName ++ '#' ++ vrNum ++ '@' ++ pgid
  }

  effect method defineViewFocus( vfName= 'view-focus' ) {
    # use a shared counter to ensure uniqueness per view-focus definition
    vfNum = ai pgData.nViewFocuses+=1
    return vfName ++ '#' ++ vfNum ++ '@' ++ pgid
  }

  effect method defineAxisCursor( acName= 'axis-cursor' ) {
    # use a shared counter to ensure uniqueness per axis-cursor definition
    acNum = ai pgData.nAxisCursors+=1
    return acName ++ '#' ++ acNum ++ '@' ++ pgid
  }

  for (hskiPeer, svcScope) from perform @haskItServer.wsClientsOn('/') do {

    {##
Open the client narrator window identified by `pnid`, vend effectful API to setup narrations in it
     #}
    effect generator narrWindow( pnid ) {
      # open the specified narr window from this root client window, establish the comm channel to it
      narrChannel = str( UUID() )
      narrSink = hskiPeer.armChannel( narrChannel )
      for ack from (outlet= narrSink )|() =>* {
        hskiPeer.postCommand( js!expr {
            void openNarrWindow( {$ pgid $}, {$ pnid $}, {$ narrChannel $} )
        } )
      } do {
        if ack is not 'narr-win-open'
        then error$ 'bug: bad handshake, check narr/narr-relay.mjs'

        break
      }

      # intermediate data for the narr window
      namespace pnData () {
      }

      effect method postJsCode( jsExpr ) {
        hskiPeer.p2c( narrChannel, js!expr ( {
              narrCmd : {$str$ jsExpr $}
        } ) )
      }

      yield ()
    }

    {##
Open the client plot window identified by `pwid`, vend effectful API to plot figures with glyphs in it
     #}
    effect generator plotWindow( pwid ) {
      # open the specified plot window from this root client window, establish the comm channel to it
      plotChannel = str( UUID() )
      plotSink = hskiPeer.armChannel( plotChannel )
      for ack from (outlet= plotSink )|() =>* {
        hskiPeer.postCommand( js!expr {
            void openPlotWindow( {$ pgid $}, {$ pwid $}, {$ plotChannel $} )
        } )
      } do {
        if ack is not 'plot-win-open'
        then error$ 'bug: bad handshake, check haze/plot-relay.mjs'

        break
      }

      # intermediate data for the plot window
      namespace pwData () {
        nds = 0
      }

      effect method defineDataSource(** cols ) {
        dsNum = ai pwData.nds+=1
        dsName = 'ds' + dsNum

        let ( colNames, colDtypes, ) = (*unzip$ for ( k, v ) from cols
          do ( k, v.dtype|str, )
        )
        # hskiDebug.replHere()
        hskiPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$str$ js!expr
                receiveDataSource(
                  {$ dsName $},
                  {$snippet$json$ colNames $},
                  {$snippet$json$ colDtypes $},
                )
              $}
        } ) )
        for ( _k, v ) from cols do {
          hskiPeer.p2c( plotChannel, js!expr ( { nextDir : 'data' } ) )
          hskiPeer.p2c( plotChannel, blob$ v )
        }

        return snippet$ 'plotData['++repr(dsName)++']'
      }

      effect method postJsCode( jsExpr ) {
        hskiPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$str$ jsExpr $}
        } ) )
      }

      yield ()
    }

    yield ()
  }

}
