{#
 # plotting procedures
 #}

import * 'haskit'


export data jsSnippet ( jsSrc ) {
  method __repr__() this.jsSrc
  __str__ = __repr__
}


PlotScript :=: {
  # these effects materialized in module `haskit/web/ws/__main__.edh`
  effect {
    # will be the HaskItServer passed in
    hski :: HaskItServer
    # the peer object connected through WebSocket,
    # from root window of the web client
    hskiPeer :: Peer
    # standard data channel sink by Nedh convention
    ; @dataSink :: EventSink
    # also the same peer object as `hskiPeer`, by Nedh convention
    ; @netPeer :: Peer
  }
} => () -> 'the group plot script'!Any
plot :: ( HaskItServer, 'the plot group id'!Any, PlotScript, ) -> nil
export method plot( hski, pgid, grpPlotScript ) {
  hski ?= HaskItServer() # hinting VSCode for code navigation

  # note outer most curly braces are being interpreted as markers of a
  # block of code in js `eval`, need to get it parenthese quoted

  # intermediate data for the plot group
  namespace pgData( pgid= pgid, ) {
    naxes = 0
  }

  hski.clientsEachDo $ crPeer => {

    effect method defineAxis( axisName= 'axis' ) {
      # use a shared counter to isolate different root client windows from
      # synchronizing axes with eachothers
      axisNum = ai pgData.naxes+=1
      return axisName ++ '#' ++ axisNum ++ '@' ++ pgid
    }

    effect method plotWindow( pwid, winPlotScript ) {
      # open a new plot window from this root client window, establish the
      # comm channel to it
      plotChannel = str( UUID() )
      plotSink = crPeer.armChannel( plotChannel )
      for ack from ( outlet= plotSink ) | () =>* {
        crPeer.postCommand( js!expr {
            void openPlotWindow( {$ pgid $}, {$ pwid $}, {$ plotChannel $} )
        } )
      } do {
        if ack is not 'plot-win-open'
        then error$ 'bug: bad handshake, check haze/plot-relay.mjs'

        break
      }

      # intermediate data for the plot window
      namespace pwData () {
        nds = 0
      }

      effect method defineDataSource(** cols ) {
        dsNum = ai pwData.nds+=1
        dsName = 'ds' + dsNum

        colNames = [] =< for ( k, _v ) from cols do k
        colDtypes = [] =< for ( _k, v ) from cols do str( v.dtype )
        crPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$ str$ js!expr
                receiveDataSource(
                  {$ dsName $}, {$ colNames $}, {$ colDtypes $},
                )
              $}
        } ) )
        for ( _k, v ) from cols do {
          crPeer.p2c( plotChannel, js!expr ( { nextDir : 'data' } ) )
          crPeer.p2c( plotChannel, blob$ v )
        }

        return dsName
      }

      effect method postJsCode( jsExpr ) {
        crPeer.p2c( plotChannel, js!expr ( {
              plotCmd : {$ str$ jsExpr $}
        } ) )
      }

      winPlotScript()
    }

    grpPlotScript()
  }

}
