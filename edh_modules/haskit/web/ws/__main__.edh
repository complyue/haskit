
{#
 # this is the client-facing entry module for a WebSocket endpoint.
 #
 # this module is instantiated and run per WebSocket connection, the
 # client is disconnected once this module finished running.
 #}

import ( Peer, **_ ) 'net/RT'
import * 'net/symbols'
effect import * 'net/effects'


# a Peer object should have been implanted atomically, the following
# line should have no technical effect but to hint an IDE for code
# completion etc.
peer ?= Peer()

console.debug<| 'WebSocket client connected - ' ++ peer
defer {
  console.debug<| 'Disconnecting ws client ' ++ peer
}

# define various effectful artifacts used for communication with this
# connected consumer client session, with `@netPeer` and `@dataSink` the
# minimum by convention
#
# note in assignments to symbolic attributes, semicolon before `@` is likely
# needed or the `@` may be parsed as an operator
effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan ?:= 'data' )
}


# should have been implanted by per-connection peer module init method
hskiServer ?= HaskItServer()

# HaskIt specific effectful artifacts for commands to be landed here
effect {
  hski = hskiServer
  hskiPeer = peer
}


# keep landing commands from browser over WebSocket
{

  # host web client actions with the effectful context here
  perceive hskiServer.wcaSink { wcAction } -> {
    # carry out such an action asynchronously, as some of them should block
    # wait for some data stream (i.e. channel) of this connection
    go wcAction( peer )
  }


  while peer.eol() is false case peer.readCommand() of {@
    { cmdVal } -> {
      console.warn<| 'Unexpected command result from ws: ' ++ desc( cmdVal )
    }
  @}

} $=> { exc } -> {
  console.error<| 'Exception by ws client ' ++ peer
  ++ ' error: ' ++ desc( exc )
}
