
{#
 # this is the client-facing entry module for a WebSocket endpoint.
 #
 # this module is instantiated and run per WebSocket connection, the
 # client is disconnected once this module finished running.
 #}

import ( Peer, ** ) 'net/RT'
import * 'net/symbols'
effect import * 'net/effects'

import * 'haskit'

effect import * './cds'


if false then { # hint the assumed environment

  # a Peer object representing the ws connection should have been implanted
  peer =: Peer()

  # reqPath & reqParams should have been implanted as well, reflecting ws request path and query parameters
  reqPath =: '/'
  reqParams =: ( s= '<session-id>', )

  # `@haskItServer` should have been implanted by per-connection peer module init method
  ; @haskItServer =: HaskItServer()
}

defer {
  console.debug<| 'Disconnecting ws client - [' ++ reqPath ++ '] ' ++ peer
}
console.debug<| 'WebSocket client connected - [' ++ reqPath ++ '] ' ++ peer


# define various effectful artifacts used for communication with this
# connected consumer client session, with `@netPeer` and `@dataSink` the
# minimum by convention
#
# note in assignments to symbolic attributes, semicolon before `@` is likely
# needed or the `@` may be parsed as an operator
effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan ?:= 'data' )
}


# HaskIt specific effectful artifacts for commands to be landed here
effect {
  ; @haskItServer = @haskItServer
  ; @haskItPeer = peer
}


if not @haskItServer.hookWsClient() then {
  # keep landing commands from browser over WebSocket

  while peer.eol() is false case peer.readCommand() of {@
    { cmdVal } -> {
      console.warn<| 'Unexpected command result from ws: ' ++ desc( cmdVal )
    }
  @}

} $=> { exc } -> {
  console.error<| 'Exception by ws client ' ++ peer ++ ' error: ' ++ desc( exc )
}
